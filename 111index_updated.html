<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Backgammon Stars</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
* { box-sizing: border-box; }
body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0c0e10; color:#e7e9ea; }
.topbar { display:flex; justify-content:space-between; align-items:center; padding:12px 16px; background:#15181c; border-bottom:1px solid #222; position:sticky; top:0; z-index:10; }
.topbar h1 { margin:0; font-size:18px; letter-spacing:0.5px; }
.balances span { margin-left:16px; opacity:0.9; }
#app { max-width: 1280px; margin: 0 auto; }
.card { background:#13161a; margin:16px; padding:16px; border:1px solid #222; border-radius:10px; }
.row { display:flex; gap:8px; align-items:center; margin:8px 0; flex-wrap: wrap; }
input, select, button { padding:10px 12px; border-radius:8px; border:1px solid #2b2f36; background:#0f1114; color:#e7e9ea; }
button { cursor:pointer; }
button.accent { background:#1f4bfd; border-color:#3d5bfd; }
button:disabled { opacity:0.5; cursor:not-allowed; }
.hidden { display:none; }
.hint { opacity:0.7; }
.warn { margin-top:10px; }
.gamebar { display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid #222; }
.dice { display:flex; align-items:center; gap:8px; }
#boardContainer { padding:12px; display:flex; justify-content:center; }
.legend { display:flex; gap:16px; justify-content:center; opacity:0.85; margin:8px 0 16px; }
.legend .p1::before { content:''; display:inline-block; width:12px; height:12px; margin-right:6px; background:#f5f5f5; border:1px solid #999; vertical-align:middle; }
.legend .p2::before { content:''; display:inline-block; width:12px; height:12px; margin-right:6px; background:#111; border:1px solid #555; vertical-align:middle; }
.foot { padding:24px; text-align:center; opacity:0.6; }
#board { border:1px solid #333; border-radius:8px; background:#1b1f24; }

  </style>
</head>
<body>
  <div id="app">
    <header class="topbar">
      <h1>Backgammon Stars</h1>
      <div class="balances">
        <span>⭐ Реальные: <b id="realStars">0</b></span>
        <span>★ Виртуальные: <b id="virtualStars">0</b></span>
      </div>
    </header>

    <section id="lobbySection" class="card">
      <h2>Лобби</h2>
      <div id="userInfo" style="margin-bottom:10px;opacity:0.8;"></div>
      <div class="row">
        <label>Тип матча:</label>
        <select id="matchType">
          <option value="virtual_bot">Виртуальные звёзды vs Бот</option>
          <option value="real_online">Реальные звёзды Онлайн (ставка оба вносят)</option>
        </select>
      </div>
      <div class="row">
        <label>Ставка:</label>
        <input id="stake" type="number" min="1" value="10"/>
        <span class="hint">Рейк 10% удерживается только со ставок реальными звёздами (онлайн).</span>
      </div>
      <div class="row">
        <button id="startMatchBtn">Начать матч</button>
        <button id="addVirtualBtn">+100 виртуальных</button>
        <button id="buyRealBtn" class="accent" title="Покупки только за реальные — тут мок-оплата отключена.">Купить реальные (OFF)</button>
      </div>
      <details class="warn">
        <summary>Важно</summary>
        <ul>
          <li>Покупки доступны только за реальные звёзды. Кнопка оплаты отключена (заглушка).</li>
          <li>За победу авто-награда не выдаётся. Изменение баланса идёт только через ставки.</li>
          <li>В режиме виртуальных звёзд — игра с ботом.</li>
          <li>В режиме реальных звёзд — онлайн-матч (заглушка матчера, без реального сервера).</li>
        </ul>
      </details>
    </section>

    <section id="gameSection" class="hidden">
      <div class="gamebar">
        <button id="backToLobby">&larr; В лобби</button>
        <div class="dice">
          <button id="rollBtn">Бросить кости</button>
          <span id="diceValues">—</span>
        </div>
        <div id="turnInfo">Ход: —</div>
      </div>
      <div id="boardContainer">
        <canvas id="board" width="1200" height="800"></canvas>
      </div>
      <div class="legend">
        <span class="p1">Игрок: белые</span>
        <span class="p2">Оппонент: чёрные</span>
      </div>
    </section>

    <footer class="foot">
      <small>© Backgammon Stars — Telegram Mini App версия.</small>
    </footer>
  </div>
  <script>
/* Backgammon Stars prototype */
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

// --- Simple state ---
const state = {
  user: null,
  balances: { real: 0, virtual: 100 },
  match: null, // { type, stake, currentPlayer, dice, diceUsed, board }
};

const authSection = $("#authSection");
const lobbySection = $("#lobbySection");
const gameSection = $("#gameSection");

const realStarsEl = $("#realStars");
const virtualStarsEl = $("#virtualStars");

function renderBalances() {
  realStarsEl.textContent = state.balances.real;
  virtualStarsEl.textContent = state.balances.virtual;
}

function saveLocal() {
  localStorage.setItem("bg_user", JSON.stringify(state.user));
  localStorage.setItem("bg_balances", JSON.stringify(state.balances));
}

function loadLocal() {
  const u = localStorage.getItem("bg_user");
  const b = localStorage.getItem("bg_balances");
  if (u) state.user = JSON.parse(u);
  if (b) state.balances = JSON.parse(b);
}

loadLocal();
renderBalances();

// --- Auth ---
$("#loginBtn").addEventListener("click", () => {
  const login = $("#login").value.trim();
  const password = $("#password").value;
  if (!login || !password) return alert("Введите логин и пароль");

  // Local-only auth (no server); accept any (store hashed-ish token)
  state.user = { login, token: btoa(login + ":" + password) };
  saveLocal();
  authSection.classList.add("hidden");
  lobbySection.classList.remove("hidden");
});

if (state.user) {
  authSection.classList.add("hidden");
  lobbySection.classList.remove("hidden");
}

// --- Lobby actions ---
$("#addVirtualBtn").addEventListener("click", () => {
  state.balances.virtual += 100;
  saveLocal(); renderBalances();
});

$("#buyRealBtn").addEventListener("click", () => {
  alert("Покупки только за реальные — оплата отключена (заглушка).");
});

$("#startMatchBtn").addEventListener("click", () => {
  const type = $("#matchType").value;
  const stake = Math.max(1, parseInt($("#stake").value || "0", 10));
  if (type === "virtual_bot") {
    if (state.balances.virtual < stake) return alert("Недостаточно виртуальных звёзд");
    state.balances.virtual -= stake; // put into pot
    startGame({ type, stake, rake: 0, opponent: "bot" });
  } else if (type === "real_online") {
    // real stars only, 10% rake
    const rake = Math.floor(stake * 0.10);
    const total = stake + rake;
    if (state.balances.real < total) return alert(`Нужно ${total} реальных звёзд (включая 10% рейк)`);
    state.balances.real -= total;
    // Normally we would match with another player + escrow pot on server; here it's a stub.
    startGame({ type, stake, rake, opponent: "stub_online" });
  }
  saveLocal(); renderBalances();
});

$("#backToLobby").addEventListener("click", () => {
  gameSection.classList.add("hidden");
  lobbySection.classList.remove("hidden");
});

// --- Board rendering ---
const canvas = $("#board");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const POINTS = 24;
const CHECKERS_PER_SIDE = 15;

// Standard starting positions (index 0 is top-right going clockwise)
const START_POS = {
  // Using arrays of stacks: board[point] = {color: 'W'|'B', count: n} or null
  // We'll map to 0..23 with 23 at top-left and 0 at top-right (like common implementation)
  layout: (() => {
    const b = Array(POINTS).fill(null).map(_=>({color:null,count:0}));
    const set = (i,c,n)=>{b[i]={color:c,count:n};};

    // White (player) traditional start
    set(23, 'W', 2); // 24-point
    set(12, 'W', 5); // 13-point
    set(7,  'W', 3); // 8-point
    set(5,  'W', 5); // 6-point

    // Black (opponent)
    set(0,  'B', 2); // 1-point
    set(11, 'B', 5); // 12-point
    set(16, 'B', 3); // 17-point
    set(18, 'B', 5); // 19-point

    return b;
  })()
};

function cloneBoard(b){ return b.map(p=>({color:p.color,count:p.count})); }

function startGame({type, stake, rake, opponent}){
  state.match = {
    type, stake, rake, opponent,
    currentPlayer: 'W', // W = user, B = opponent
    dice: [], diceUsed: [],
    board: cloneBoard(START_POS.layout),
    off: {W:0, B:0}, bar: {W:0, B:0},
  };
  lobbySection.classList.add("hidden");
  gameSection.classList.remove("hidden");
  updateTurnInfo();
  drawBoard();
  $("#diceValues").textContent = "—";
}

function updateTurnInfo(){
  $("#turnInfo").textContent = `Ход: ${state.match.currentPlayer==='W'?'Игрок':'Оппонент'}`;
}

function drawBoard(){
  ctx.clearRect(0,0,W,H);
  // Background
  ctx.fillStyle = "#2a2f37";
  ctx.fillRect(0,0,W,H);

  // Draw points (triangles)
  const margin = 30, boardW = W - margin*2, boardH = H - margin*2;
  const midGap = 80;
  const pointW = boardW/12;
  const topH = (boardH - midGap)/2;
  const bottomY = margin + topH + midGap;

  // Wood-like split
  ctx.fillStyle = "#1f232a";
  ctx.fillRect(margin, margin, boardW, topH);
  ctx.fillRect(margin, bottomY, boardW, topH);

  for (let i=0; i<12; i++){
    // top row, points 12..23 left-to-right for drawing
    const x = margin + i*pointW;
    const isLight = i%2===0;
    ctx.beginPath();
    ctx.moveTo(x + pointW/2, margin);
    ctx.lineTo(x, margin + topH);
    ctx.lineTo(x + pointW, margin + topH);
    ctx.closePath();
    ctx.fillStyle = isLight? "#b07f2f" : "#5a3a12";
    ctx.fill();
  }
  for (let i=0; i<12; i++){
    // bottom row, points 11..0 left-to-right for drawing
    const x = margin + i*pointW;
    const isLight = i%2===0;
    ctx.beginPath();
    ctx.moveTo(x + pointW/2, margin + topH + midGap + topH);
    ctx.lineTo(x, margin + topH + midGap);
    ctx.lineTo(x + pointW, margin + topH + midGap);
    ctx.closePath();
    ctx.fillStyle = isLight? "#b07f2f" : "#5a3a12";
    ctx.fill();
  }

  // Draw checkers on points
  const checkerR = Math.min(pointW*0.42, 26);
  const stackSpacing = checkerR*1.1;

  const positions = pointPositions(); // array of {x,yTop,yBottom,index}
  for (const p of positions){
    const cell = state.match.board[p.index];
    if (!cell || !cell.color || !cell.count) continue;
    const upward = p.up;
    for (let k=0;k<cell.count;k++){
      const cx = p.x;
      const cy = upward
        ? (margin + topH - checkerR - k*stackSpacing)
        : (bottomY + checkerR + k*stackSpacing);
      drawChecker(cx, cy, cell.color==='W');
    }
  }

  // Off & bar (simple text)
  ctx.fillStyle = "#fff"; ctx.font = "14px system-ui";
  ctx.fillText(`Снято (W): ${state.match.off.W}`, W-180, 24);
  ctx.fillText(`Снято (B): ${state.match.off.B}`, W-180, 42);
  ctx.fillText(`Бар (W): ${state.match.bar.W}`, 20, 24);
  ctx.fillText(`Бар (B): ${state.match.bar.B}`, 20, 42);
}

function drawChecker(x,y,isWhite){
  ctx.beginPath();
  ctx.arc(x,y,24,0,Math.PI*2);
  ctx.fillStyle = isWhite ? "#f5f5f5" : "#111";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = isWhite ? "#999" : "#555";
  ctx.stroke();
}

function pointPositions(){
  // Return mapping to canvas coordinates and whether stacks go up (top) or down (bottom)
  const pos = [];
  const margin = 30, boardW = W - margin*2, boardH = H - margin*2;
  const midGap = 80;
  const pointW = boardW/12;
  const topH = (boardH - midGap)/2;
  const bottomY = margin + topH + midGap;

  // top row (points 12..23)
  for (let i=0;i<12;i++){
    const index = 12+i; // 12..23
    const x = margin + i*pointW + pointW/2;
    pos.push({index, x, up:true});
  }
  // bottom row (points 11..0)
  for (let i=0;i<12;i++){
    const index = 11-i; // 11..0
    const x = margin + i*pointW + pointW/2;
    pos.push({index, x, up:false});
  }
  return pos;
}

// --- Dice & moves (simplified rules) ---
$("#rollBtn").addEventListener("click", () => {
  if (!state.match) return;
  if (state.match.currentPlayer === 'B') return; // wait bot
  if (state.match.dice.length && state.match.diceUsed.some(u=>!u)) return alert("Сначала используйте текущие ходы");

  rollDice();
  drawBoard();
});

function rollDice(){
  const a = 1+Math.floor(Math.random()*6);
  const b = 1+Math.floor(Math.random()*6);
  const dice = (a===b)? [a,a,a,a] : [a,b];
  state.match.dice = dice;
  state.match.diceUsed = dice.map(_=>false);
  $("#diceValues").textContent = dice.join(" / ");
}

canvas.addEventListener("click", onBoardClick);
let selectedPoint = null;

function onBoardClick(ev){
  if (!state.match) return;
  if (state.match.currentPlayer!=='W') return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const pos = pointPositions();
  // find nearest point by x; ignore y for simplicity
  let best = null, bestd = 1e9;
  for (const p of pos){
    const dx = Math.abs(p.x - x);
    if (dx < bestd){ bestd=dx; best=p; }
  }
  if (!best) return;

  if (selectedPoint===null){
    // select source if it's white
    const src = state.match.board[best.index];
    if (src && src.color==='W' && src.count>0){
      selectedPoint = best.index;
    }
  } else {
    const srcIdx = selectedPoint;
    const dstIdx = best.index;
    if (tryMove('W', srcIdx, dstIdx)){
      selectedPoint = null;
      drawBoard();
      if (allDiceUsed()) {
        endTurnOrBot();
      }
    } else {
      // if clicking same color point, reselect
      const src = state.match.board[best.index];
      if (src && src.color==='W' && src.count>0){
        selectedPoint = best.index;
      } else {
        selectedPoint = null;
      }
    }
  }
}

function allDiceUsed(){ return state.match.diceUsed.every(x=>x); }

function tryMove(color, srcIdx, dstIdx){
  // direction: W moves from 23 -> 0 (descending), B moves 0 -> 23
  const dir = (color==='W')? -1 : +1;
  const dist = Math.abs(dstIdx - srcIdx);
  const legalSteps = state.match.dice
    .map((d,i)=>({d,i}))
    .filter(o=>!state.match.diceUsed[o.i])
    .map(o=>o.d);

  if (!legalSteps.includes(dist)) return false;

  // source has checker of color?
  const src = state.match.board[srcIdx];
  if (!src || src.color!==color || src.count===0) return false;

  // destination blocked? (max 1 opponent checker allowed — then it's a hit; we skip bar mechanics here for simplicity)
  const dst = state.match.board[dstIdx];
  if (dst && dst.color && dst.color!==color && dst.count>1) return false;

  // move
  src.count--;
  if (src.count===0){ src.color=null; }

  if (dst && dst.color && dst.color!==color && dst.count===1){
    // hit: send to bar (simplified: just remove and don't implement re-entry)
    state.match.bar[dst.color]++;
    state.match.board[dstIdx] = {color: color, count:1};
  } else {
    if (!dst || !dst.color){
      state.match.board[dstIdx] = {color, count:1};
    } else {
      // same color
      state.match.board[dstIdx].count++;
      state.match.board[dstIdx].color = color;
    }
  }

  // mark dice used (first matching distance)
  for (let i=0;i<state.match.dice.length;i++){
    if (!state.match.diceUsed[i] && state.match.dice[i]===dist){
      state.match.diceUsed[i]=true; break;
    }
  }

  // very simplified bear-off: if all checkers in home (W: 0..5), allow moving exactly off from within 1..6
  if (color==='W' && inHome('W') && dstIdx<=5){
    // if exact move would go past 0..5, allow bearing off if no higher point has checkers
    // for simplicity, require exact match: moving to -1 not implemented; we just allow remove when on 0..5 and die equals from distance to off (dst to -1)
    // We'll implement: if checker on p (0..5) and you use a die equal to p+1, bear off
  }

  return true;
}

function inHome(color){
  if (color==='W'){
    // points 0..5
    for (let i=6;i<24;i++){
      const p = state.match.board[i];
      if (p.color==='W' && p.count>0) return false;
    }
    return true;
  } else {
    for (let i=0;i<18;i++){
      const p = state.match.board[i];
      if (p.color==='B' && p.count>0) return false;
    }
    return true;
  }
}

function endTurnOrBot(){
  // Switch turn, let bot move
  state.match.currentPlayer = (state.match.currentPlayer==='W')? 'B':'W';
  updateTurnInfo();
  $("#diceValues").textContent = "—";
  setTimeout(botTurn, 600);
}

function botTurn(){
  if (!state.match || state.match.currentPlayer!=='B') return;
  rollDice();
  // Bot: random legal single-step moves using dice
  const moves = listAllSimpleMoves('B');
  for (const m of moves){
    tryMove('B', m.src, m.dst);
  }
  drawBoard();
  state.match.currentPlayer = 'W';
  updateTurnInfo();
  $("#diceValues").textContent = "—";
}

function listAllSimpleMoves(color){
  const res = [];
  const dir = (color==='W')? -1 : +1;
  for (let i=0;i<24;i++){
    const cell = state.match.board[i];
    if (cell.color!==color || cell.count===0) continue;
    for (let di=0; di<state.match.dice.length; di++){
      if (state.match.diceUsed[di]) continue;
      const d = state.match.dice[di];
      const dst = i + d*dir;
      if (dst<0 || dst>23) continue;
      const target = state.match.board[dst];
      if (!target.color || target.color===color || target.count===1){
        // legal
        res.push({src:i,dst});
        state.match.diceUsed[di]=true; // pretend use, but don't mutate real state
      }
    }
  }
  // shuffle and take a few
  for (let i=res.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1)); const t=res[i]; res[i]=res[j]; res[j]=t;
  }
  // revert diceUsed after simulation
  state.match.diceUsed = state.match.dice.map(_=>false);
  // choose up to 2 moves (if not doubles)
  return res.slice(0,2);
}


// Telegram Mini App init
const tg = window.Telegram.WebApp;
tg.expand();
let tgUser = tg.initDataUnsafe?.user;
if(tgUser){
  document.getElementById('userInfo').textContent = tgUser.first_name + (tgUser.last_name ? ' ' + tgUser.last_name : '');
} else {
  document.getElementById('userInfo').textContent = '(Гость)';
}
// Auto init user state
state.user = tgUser || { login: 'guest' };
state.balances = { real: 0, virtual: 100 };
renderBalances();

// Принудительная активация кнопок сразу при загрузке
document.getElementById('startMatchBtn').addEventListener('click', () => {
  const type = document.getElementById('matchType').value;
  const stake = Math.max(1, parseInt(document.getElementById('stake').value || "0", 10));
  if (type === "virtual_bot") {
    if (state.balances.virtual < stake) return alert("Недостаточно виртуальных звёзд");
    state.balances.virtual -= stake;
    startGame({ type, stake, rake: 0, opponent: "bot" });
  } else if (type === "real_online") {
    const rake = Math.floor(stake * 0.10);
    const total = stake + rake;
    if (state.balances.real < total) return alert(`Нужно ${total} реальных звёзд (включая 10% рейк)`);
    state.balances.real -= total;
    startGame({ type, stake, rake, opponent: "stub_online" });
  }
  saveLocal(); renderBalances();
});

document.getElementById('addVirtualBtn').addEventListener('click', () => {
  state.balances.virtual += 100;
  saveLocal(); renderBalances();
});

document.getElementById('buyRealBtn').addEventListener('click', () => {
  alert("Покупки только за реальные — оплата отключена (заглушка).");
});

document.getElementById('backToLobby').addEventListener('click', () => {
  gameSection.classList.add("hidden");
  lobbySection.classList.remove("hidden");
});
  </script>
</body>
</html>
